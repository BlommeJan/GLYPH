<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLYPH | Text Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #0f0f10;
            color: #e2e2e2;
            font-family: 'Inter', sans-serif;
        }
        .editor-font {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Custom Scrollbar */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #0f0f10;
        }
        textarea::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .btn {
            transition: all 0.2s ease;
        }
        .btn:active {
            transform: scale(0.95);
        }
        /* Drag overlay */
        .drag-active {
            border: 2px dashed #6366f1;
            background-color: #1a1a20;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden selection:bg-indigo-500 selection:text-white">

    <!-- Header -->
    <header class="flex justify-between items-center px-6 py-4 border-b border-gray-800 bg-[#0f0f10] shrink-0">
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 bg-indigo-500 rounded-full animate-pulse"></div>
            <h1 class="text-xl font-bold tracking-widest text-white select-none">GLYPH</h1>
        </div>
        
        <div class="flex items-center gap-4">
            <div id="status" class="text-xs text-indigo-400 font-mono opacity-0 transition-opacity duration-300 hidden md:block">
                ACTION COMPLETE
            </div>
            
            <!-- Quick Actions -->
            <div class="flex items-center gap-2 border-l border-gray-800 pl-4">
                <button onclick="copyToClipboard()" class="p-2 text-gray-400 hover:text-white hover:bg-gray-800 rounded transition-colors" title="Copy to Clipboard">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                </button>
                <button onclick="clearEditor()" class="p-2 text-gray-400 hover:text-red-400 hover:bg-gray-800 rounded transition-colors" title="Clear All">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Editor -->
    <main class="flex-grow flex flex-col relative group">
        <textarea 
            id="editor" 
            class="w-full h-full bg-[#0f0f10] text-gray-300 p-6 md:p-8 resize-none focus:outline-none editor-font text-sm md:text-base leading-relaxed transition-colors duration-200"
            placeholder="Type, paste, or drag a text file here..."
            spellcheck="false"
        ></textarea>
        
        <!-- Character Count -->
        <div class="absolute bottom-4 right-6 text-xs text-gray-600 font-mono pointer-events-none transition-opacity group-hover:opacity-100 opacity-50">
            <span id="char-count">0</span> chars
        </div>
    </main>

    <!-- Toolbar -->
    <footer class="bg-[#18181b] border-t border-gray-800 p-4 shrink-0 z-10">
        <div class="max-w-4xl mx-auto flex flex-col sm:flex-row justify-between items-center gap-4">
            <div class="text-xs text-gray-500 hidden sm:block font-mono">
                <span class="text-indigo-500">CTRL+S</span> TO QUICK SAVE .TXT
            </div>
            
            <div class="flex gap-3 w-full sm:w-auto">
                <button id="btn-txt" onclick="exportFile('txt')" class="btn flex-1 sm:flex-none bg-gray-800 hover:bg-gray-700 text-white px-6 py-2 rounded text-sm font-medium border border-gray-700 hover:border-gray-600 min-w-[100px]">
                    .TXT
                </button>
                <button id="btn-md" onclick="exportFile('md')" class="btn flex-1 sm:flex-none bg-gray-800 hover:bg-gray-700 text-white px-6 py-2 rounded text-sm font-medium border border-gray-700 hover:border-gray-600 min-w-[100px]">
                    .MD
                </button>
                <button id="btn-pdf" onclick="exportFile('pdf')" class="btn flex-1 sm:flex-none bg-indigo-600 hover:bg-indigo-500 text-white px-6 py-2 rounded text-sm font-medium shadow-lg shadow-indigo-500/20 min-w-[100px]">
                    .PDF
                </button>
            </div>
        </div>
    </footer>

    <script>
        const editor = document.getElementById('editor');
        const statusEl = document.getElementById('status');
        const charCountEl = document.getElementById('char-count');

        // --- Core Logic & Persistence ---

        // Load from local storage on boot
        window.addEventListener('load', () => {
            const saved = localStorage.getItem('glyph_content');
            if (saved) {
                editor.value = saved;
                updateCount();
            }
            editor.focus();
        });

        // Save to local storage on input
        editor.addEventListener('input', () => {
            updateCount();
            localStorage.setItem('glyph_content', editor.value);
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                exportFile('txt');
            }
        });

        function updateCount() {
            charCountEl.textContent = editor.value.length.toLocaleString();
        }

        // --- UX Actions ---

        function showStatus(msg) {
            statusEl.textContent = msg;
            statusEl.classList.remove('opacity-0');
            setTimeout(() => {
                statusEl.classList.add('opacity-0');
            }, 2000);
        }

        async function copyToClipboard() {
            if (!editor.value) return;
            try {
                await navigator.clipboard.writeText(editor.value);
                showStatus("COPIED TO CLIPBOARD");
            } catch (err) {
                showStatus("COPY FAILED");
            }
        }

        function clearEditor() {
            if (editor.value.length > 0 && confirm("Clear the void? This cannot be undone.")) {
                editor.value = '';
                localStorage.removeItem('glyph_content');
                updateCount();
                showStatus("CLEARED");
            }
        }

        // --- Drag & Drop Support ---
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            editor.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        editor.addEventListener('dragenter', () => editor.classList.add('drag-active'));
        editor.addEventListener('dragleave', () => editor.classList.remove('drag-active'));
        
        editor.addEventListener('drop', (e) => {
            editor.classList.remove('drag-active');
            const file = e.dataTransfer.files[0];
            if (file && (file.type.startsWith('text/') || file.name.endsWith('.md') || file.name.endsWith('.txt'))) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    editor.value = e.target.result;
                    localStorage.setItem('glyph_content', editor.value);
                    updateCount();
                    showStatus("FILE LOADED");
                };
                reader.readAsText(file);
            } else {
                showStatus("TEXT FILES ONLY");
            }
        });

        // --- Export Logic ---

        function getFilename(ext) {
            const content = editor.value.trim();
            let name = 'glyph_export';
            
            if (content.length > 0) {
                const firstWords = content.split(/\s+/).slice(0, 3).join('_');
                name = firstWords.replace(/[^a-zA-Z0-9_]/g, '').substring(0, 20) || 'glyph_export';
            }
            return `${name}.${ext}`;
        }

        function animateButton(type) {
            const btn = document.getElementById(`btn-${type}`);
            if(btn) {
                const originalText = btn.innerText;
                btn.innerText = "DONE";
                setTimeout(() => btn.innerText = originalText, 1000);
            }
        }

        async function exportFile(type) {
            const content = editor.value;
            
            if (!content) {
                showStatus("THE VOID IS EMPTY");
                return;
            }

            const filename = getFilename(type);

            if (type === 'pdf') {
                showStatus("GENERATING PDF...");
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'p',
                        unit: 'mm',
                        format: 'a4'
                    });

                    doc.setFont("courier", "normal");
                    doc.setFontSize(11);
                    
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 20;
                    const maxLineWidth = pageWidth - (margin * 2);
                    const lineHeight = 7;
                    
                    const textLines = doc.splitTextToSize(content, maxLineWidth);
                    
                    let cursorY = margin;
                    
                    textLines.forEach(line => {
                        if (cursorY + lineHeight > pageHeight - margin) {
                            doc.addPage();
                            cursorY = margin;
                        }
                        doc.text(line, margin, cursorY);
                        cursorY += lineHeight;
                    });

                    doc.save(filename);
                    showStatus("PDF EXPORTED");
                    animateButton('pdf');
                } catch (e) {
                    console.error(e);
                    showStatus("PDF ERROR");
                }

            } else {
                const mimeType = type === 'md' ? 'text/markdown' : 'text/plain';
                const blob = new Blob([content], { type: mimeType });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    showStatus(`${type.toUpperCase()} EXPORTED`);
                    animateButton(type);
                }, 0);
            }
        }
    </script>
</body>
</html>
